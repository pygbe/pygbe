<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygbe.tree.FMMutils &#8212; PyGBe 0.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pygbe.tree.FMMutils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">It contains the functions to build the tree and compute all the interactions.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="k">import</span> <span class="n">comb</span>

<span class="c1"># Wrapped code</span>
<span class="kn">from</span> <span class="nn">pygbe.tree.multipole</span> <span class="k">import</span> <span class="n">multipole_c</span><span class="p">,</span> <span class="n">setIndex</span><span class="p">,</span> <span class="n">getIndex_arr</span><span class="p">,</span> <span class="n">multipole_sort</span><span class="p">,</span> <span class="n">multipoleKt_sort</span>
<span class="kn">from</span> <span class="nn">pygbe.tree.direct</span> <span class="k">import</span> <span class="n">direct_c</span><span class="p">,</span> <span class="n">direct_sort</span><span class="p">,</span> <span class="n">directKt_sort</span>
<span class="kn">from</span> <span class="nn">pygbe.tree.calculateMultipoles</span> <span class="k">import</span> <span class="n">P2M</span><span class="p">,</span> <span class="n">M2M</span>

<span class="c1"># CUDA libraries</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pycuda.driver</span> <span class="k">as</span> <span class="nn">cuda</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PyCUDA not installed, performance might not be so hot&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Cell"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.Cell">[docs]</a><span class="k">class</span> <span class="nc">Cell</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cell class. It contains the information about the cells in the tree.</span>

<span class="sd">    Attributes</span>
<span class="sd">    -----------</span>
<span class="sd">    nsource   : int, number of source particles.</span>
<span class="sd">    ntarget   : int, number of target particles.</span>
<span class="sd">    nchild    : int, number of child boxes in binary, 8bit value, if certain</span>
<span class="sd">                     child exists, that bit will be 1.</span>
<span class="sd">    source    : array, pointer to source particles.</span>
<span class="sd">    target    : array, pointer to target particles.</span>
<span class="sd">    xc        : float, x position of the center of cell.</span>
<span class="sd">    yc        : float, y position of the center of cell.</span>
<span class="sd">    zc        : float, z position of the center of cell.</span>
<span class="sd">    r         : float, cell radius, i.e half length.</span>
<span class="sd">    parent    : int, pointer to parent cell.</span>
<span class="sd">    child     : array, pointer to child cell.</span>
<span class="sd">    M         : array, array with multipoles.</span>
<span class="sd">    Md        : array, array with multipoles for grad(G).n.</span>
<span class="sd">    P2P_list  : list, pointer to cells that interact with P2P.</span>
<span class="sd">    M2P_list  : list, pointer to cells that interact with M2P.</span>
<span class="sd">    M2P_size  : list, size of the M2P interaction list.</span>
<span class="sd">    list_ready: int, flag to know if P2P list is already generated.</span>
<span class="sd">    twig_array: list, position in the twig array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NCRIT: int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                    structure.</span>
<span class="sd">        Nm   : int, number of multipole coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsource</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of source particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of target particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nchild</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of child boxes in binary</span>
        <span class="c1"># This will be a 8bit value and if certain</span>
        <span class="c1"># child exists, that bit will be 1.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span>
                                  <span class="p">)</span>  <span class="c1"># Pointer to source particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span>
                                  <span class="p">)</span>  <span class="c1"># Pointer to target particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># x position of cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yc</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># y position of cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zc</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># z position of cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># cell radius</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Pointer to parent cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Pointer to child cell</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nm</span><span class="p">)</span>  <span class="c1"># Array with multipoles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Md</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nm</span><span class="p">)</span>  <span class="c1"># Array with multipoles for grad(G).n</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">P2P_list</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>  <span class="c1"># Pointer to cells that interact with P2P</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M2P_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Pointer to cells that interact with M2P</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M2P_size</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Size of the M2P interaction list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_ready</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Flag to know if P2P list is already generated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twig_array</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Position in the twig array</span></div>


<div class="viewcode-block" id="add_child"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.add_child">[docs]</a><span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="n">octant</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">Ncell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It adds a child cell to the Cells.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    octant: int, octant of the child cell.</span>
<span class="sd">    Cells : array, it contains the cells information.</span>
<span class="sd">    i     : int, index of parent cell in Cells array.</span>
<span class="sd">    NCRIT : int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                 structure.</span>
<span class="sd">    Nm    : int, number of multipole coefficients.</span>
<span class="sd">    Ncell : int, number of cells in the tree.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Ncell : int, number of cells in the tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">CN</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">)</span>  <span class="c1"># CN: child cell</span>
    <span class="n">CN</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">r</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">CN</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span> <span class="o">+</span> <span class="n">CN</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">octant</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># octant&amp;X returns X if true</span>
    <span class="n">CN</span><span class="o">.</span><span class="n">yc</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span> <span class="o">+</span> <span class="n">CN</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">octant</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Want to make ((octant&amp;X)*Y - Z)=1</span>
    <span class="n">CN</span><span class="o">.</span><span class="n">zc</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span> <span class="o">+</span> <span class="n">CN</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="p">((</span><span class="n">octant</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">CN</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">Cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">octant</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ncell</span>
    <span class="n">Cells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">octant</span><span class="p">)</span>
    <span class="n">Cells</span><span class="p">[</span><span class="n">Ncell</span><span class="p">]</span> <span class="o">=</span> <span class="n">CN</span>
    <span class="n">Ncell</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">Ncell</span></div>


<div class="viewcode-block" id="split_cell"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.split_cell">[docs]</a><span class="k">def</span> <span class="nf">split_cell</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">Ncell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It splits a cell with more than (&gt;=) NCRIT particles.</span>
<span class="sd">    Particles in this context means boundary elements.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    x    : array, x position of the particles.</span>
<span class="sd">    y    : array, y position of the particles.</span>
<span class="sd">    z    : array, z position of the particles.</span>
<span class="sd">    Cells: array, it contains the cells information.</span>
<span class="sd">    C    : int, index in the Cells array of the cell to be splitted .</span>
<span class="sd">    NCRIT: int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                structure.</span>
<span class="sd">    Nm   : int, number of multipole coefficients.</span>
<span class="sd">    Ncell: int, number of cells in the tree.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Ncell: int, number of cells in the tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
        <span class="n">octant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">z</span><span class="p">[</span>
            <span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span>
                 <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">octant</span><span class="p">))):</span>  <span class="c1"># Ask if octant exists already</span>
            <span class="n">Ncell</span> <span class="o">=</span> <span class="n">add_child</span><span class="p">(</span><span class="n">octant</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">Ncell</span><span class="p">)</span>

        <span class="n">CC</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">octant</span><span class="p">]</span>  <span class="c1"># Pointer to child cell</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">NCRIT</span><span class="p">):</span>
            <span class="n">Ncell</span> <span class="o">=</span> <span class="n">split_cell</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">CC</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">Ncell</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Ncell</span></div>


<div class="viewcode-block" id="generateTree"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.generateTree">[docs]</a><span class="k">def</span> <span class="nf">generateTree</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">x_center</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It generates a target-based tree.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    xi      : array, x position of the targets, i.e collocation points.</span>
<span class="sd">    yi      : array, y position of the targets, i.e collocation points.</span>
<span class="sd">    zi      : array, z position of the targets, i.e collocation points.</span>
<span class="sd">    NCRIT   : int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                   structure.</span>
<span class="sd">    Nm      : int, number of multipole coefficients.</span>
<span class="sd">    r       : float, cell radius, i.e half length.</span>
<span class="sd">    x_center: array, center of the root cell.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Cells   : array, cells of the tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">C0</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">(</span><span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">)</span>
    <span class="n">C0</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="n">x_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">C0</span><span class="o">.</span><span class="n">yc</span> <span class="o">=</span> <span class="n">x_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">C0</span><span class="o">.</span><span class="n">zc</span> <span class="o">=</span> <span class="n">x_center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">C0</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="n">Cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cell</span><span class="p">(</span><span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span>
    <span class="n">Cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">C0</span>
    <span class="n">Ncell</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>

        <span class="n">C</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">NCRIT</span><span class="p">):</span>
            <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">octant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span>
                <span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">zi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">octant</span><span class="p">))):</span>
                <span class="n">Ncell</span> <span class="o">=</span> <span class="n">add_child</span><span class="p">(</span><span class="n">octant</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">Ncell</span><span class="p">)</span>

            <span class="n">C</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">octant</span><span class="p">]</span>

        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">NCRIT</span><span class="p">):</span>
            <span class="n">Ncell</span> <span class="o">=</span> <span class="n">split_cell</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">Ncell</span><span class="p">)</span>

    <span class="n">Cells</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[:</span><span class="n">Ncell</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Cells</span></div>


<div class="viewcode-block" id="findTwigs"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.findTwigs">[docs]</a><span class="k">def</span> <span class="nf">findTwigs</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">twig</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It finds the twig cells, the ones that have &lt; NCRIT.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    Cells: array, cells of the tree.</span>
<span class="sd">    C    : int, index of cell in the Cells array.</span>
<span class="sd">    twig : array, indices of twigs in Cells array.</span>
<span class="sd">    NCRIT: int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                structure.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    twig : array, indices of twigs in Cells array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">NCRIT</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">)):</span>
                <span class="n">twig</span> <span class="o">=</span> <span class="n">findTwigs</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">twig</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">twig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">twig_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">twig</span></div>


<div class="viewcode-block" id="addSources"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.addSources">[docs]</a><span class="k">def</span> <span class="nf">addSources</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">twig</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It adds the source points to the cells.</span>
<span class="sd">    Puts the sources in the same cell as the collocation point of the same</span>
<span class="sd">    panel.</span>
<span class="sd">    This version works fast when used with sorted arrays.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    Cells: array, cells of the tree.</span>
<span class="sd">    twig : array, indices of twigs in Cells array.</span>
<span class="sd">    K    : int, number of Gauss points per element.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">twig</span><span class="p">:</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nsource</span> <span class="o">=</span> <span class="n">K</span> <span class="o">*</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
            <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
                                           <span class="n">K</span> <span class="o">*</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">target</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span></div>


<div class="viewcode-block" id="addSources2"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.addSources2">[docs]</a><span class="k">def</span> <span class="nf">addSources2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It adds the source points to the cells.</span>
<span class="sd">    Puts the sources in the same cell as the collocation point of the same</span>
<span class="sd">    panel.</span>
<span class="sd">    This version is a generic version that loop over the cells looking for</span>
<span class="sd">    twigs and sets the sources one it finds a twig.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    x    : array, x coordinate of the sources.</span>
<span class="sd">    y    : array, y coordinate of the sources.</span>
<span class="sd">    z    : array, z coordinate of the sources.</span>
<span class="sd">    j    : int, index of the source in the source array.</span>
<span class="sd">    Cells: array, cells of the tree.</span>
<span class="sd">    C    : int, index of cell in the Cells array.</span>
<span class="sd">    NCRIT: int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">NCRIT</span><span class="p">):</span>
        <span class="n">octant</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">octant</span><span class="p">)):</span>  <span class="c1"># If child cell exists, use</span>
            <span class="n">O</span> <span class="o">=</span> <span class="n">octant</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># If child cell doesn&#39;t exist add to closest existing child</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">child</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">)):</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span><span class="o">.</span><span class="n">xc</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span><span class="o">.</span><span class="n">yc</span>
                    <span class="n">dz</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span><span class="o">.</span><span class="n">zc</span>
                    <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">dz</span> <span class="o">*</span> <span class="n">dz</span><span class="p">))</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">close_child</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>  <span class="c1"># Find index of closest child</span>
            <span class="n">O</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">close_child</span><span class="p">]</span>
        <span class="n">addSources2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">O</span><span class="p">],</span> <span class="n">NCRIT</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nsource</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>


<div class="viewcode-block" id="addSources3"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.addSources3">[docs]</a><span class="k">def</span> <span class="nf">addSources3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">twig</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It adds the source points to the cells.</span>
<span class="sd">    Puts the sources in the same cell as the collocation point of the same</span>
<span class="sd">    panel.</span>
<span class="sd">    This version works fast when we uses the twig_array, array that contains</span>
<span class="sd">    the location in the cells array of the twig cells.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    x    : array, x coordinate of the sources.</span>
<span class="sd">    y    : array, y coordinate of the sources.</span>
<span class="sd">    z    : array, z coordinate of the sources.</span>
<span class="sd">    j    : int, index of the source in the source array.</span>
<span class="sd">    Cells: array, cells of the tree.</span>
<span class="sd">    twig : array, indices of twigs in Cells array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">twig</span><span class="p">:</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span>
        <span class="n">dy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span>
        <span class="n">dz</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">dz</span> <span class="o">*</span> <span class="n">dz</span><span class="p">)</span>

    <span class="n">close_twig</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">close_twig</span><span class="p">)):</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">twig</span><span class="p">[</span><span class="n">close_twig</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span><span class="o">.</span><span class="n">nsource</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">twig</span><span class="p">[</span><span class="n">close_twig</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">Cells</span><span class="p">[</span><span class="n">twig</span><span class="p">[</span><span class="n">close_twig</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>


<div class="viewcode-block" id="sortPoints"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.sortPoints">[docs]</a><span class="k">def</span> <span class="nf">sortPoints</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">Cells</span><span class="p">,</span> <span class="n">twig</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It sort the target and source points.</span>

<span class="sd">    We sort them to makes the computation easy and faster in the GPU.</span>
<span class="sd">    We unsort them when we need the information to be analized after it was</span>
<span class="sd">    computed.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surface: class, surface that we are analysing.</span>
<span class="sd">    Cells  : array, cells of the tree.</span>
<span class="sd">    twig   : array, indices of twigs in Cells array.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Nround</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">)</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span>

    <span class="n">surface</span><span class="o">.</span><span class="n">sortTarget</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nround</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">unsort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">xi</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">xj</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">offsetSource</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">offsetTarget</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">sizeTarget</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">twig</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">offSrc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">twig</span><span class="p">:</span>
        <span class="n">surface</span><span class="o">.</span><span class="n">sortTarget</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">Cells</span><span class="p">[</span>
            <span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">target</span>
        <span class="n">surface</span><span class="o">.</span><span class="n">unsort</span><span class="p">[</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span>
            <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span><span class="p">)</span>
        <span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span><span class="p">[</span><span class="n">offSrc</span><span class="p">:</span><span class="n">offSrc</span> <span class="o">+</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nsource</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
        <span class="n">offSrc</span> <span class="o">+=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nsource</span>
        <span class="n">surface</span><span class="o">.</span><span class="n">offsetSource</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offSrc</span>
        <span class="n">surface</span><span class="o">.</span><span class="n">offsetTarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span>
        <span class="n">surface</span><span class="o">.</span><span class="n">sizeTarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">surface</span><span class="o">.</span><span class="n">xiSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">xi</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortTarget</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">yiSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">yi</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortTarget</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">ziSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">zi</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortTarget</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">xjSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">xj</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">yjSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">yj</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">zjSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">zj</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">AreaSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">area</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">//</span> <span class="n">param</span><span class="o">.</span><span class="n">K</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">sglInt_intSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">sglInt_int</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">//</span> <span class="n">param</span><span class="o">.</span><span class="n">K</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">sglInt_extSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">sglInt_ext</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">//</span> <span class="n">param</span><span class="o">.</span><span class="n">K</span><span class="p">]</span>
    <span class="n">surface</span><span class="o">.</span><span class="n">triangleSort</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">triangle</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">//</span> <span class="n">param</span><span class="o">.</span><span class="n">K</span><span class="p">]</span></div>


<div class="viewcode-block" id="computeIndices"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.computeIndices">[docs]</a><span class="k">def</span> <span class="nf">computeIndices</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">ind0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the indices (exponents) needed to compute the Taylor expansion.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    P   : int, order of the Taylor expansion.</span>
<span class="sd">    ind0: class, it contains the indices related to the treecode computation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">II</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">JJ</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">KK</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">index_large</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
        <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ii</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="n">jj</span><span class="p">):</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">setIndex</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">kk</span><span class="p">))</span>
                <span class="n">II</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                <span class="n">JJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
                <span class="n">KK</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span>
                <span class="n">ind0</span><span class="o">.</span><span class="n">index_large</span><span class="p">[(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">P</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">jj</span> <span class="o">+</span>
                                 <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">ind0</span><span class="o">.</span><span class="n">II</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">II</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">JJ</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">JJ</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">KK</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">KK</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>
<span class="c1">#    index = getIndex_arr(P,II,JJ,KK)</span>


<div class="viewcode-block" id="precomputeTerms"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.precomputeTerms">[docs]</a><span class="k">def</span> <span class="nf">precomputeTerms</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">ind0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It precomputes the terms for P2M and M2M computation.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    P   : int, order of the Taylor expansion.</span>
<span class="sd">    ind0: class, it contains the indices related to the treecode computation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Precompute terms for</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">combII</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">combJJ</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">combKK</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">IImii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">JJmjj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">KKmkk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">index_small</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">ind0</span><span class="o">.</span><span class="n">index_ptr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">II</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">II</span><span class="p">)):</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">kk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ind0</span><span class="o">.</span><span class="n">II</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ind0</span><span class="o">.</span><span class="n">JJ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span>
                                 <span class="n">ind0</span><span class="o">.</span><span class="n">KK</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">kk</span> <span class="o">=</span> <span class="n">ii</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">jj</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">kk</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">index_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">getIndex_arr</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span> <span class="n">index_aux</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">kk</span><span class="p">)</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">index_small</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">index_small</span><span class="p">,</span> <span class="n">index_aux</span><span class="p">)</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">index_ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_aux</span><span class="p">)</span> <span class="o">+</span> <span class="n">ind0</span><span class="o">.</span><span class="n">index_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">combII</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">combII</span><span class="p">,</span> <span class="n">comb</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">II</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ii</span><span class="p">))</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">combJJ</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">combJJ</span><span class="p">,</span> <span class="n">comb</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">JJ</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">jj</span><span class="p">))</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">combKK</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">combKK</span><span class="p">,</span> <span class="n">comb</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">KK</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">kk</span><span class="p">))</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">IImii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">IImii</span><span class="p">,</span> <span class="n">ind0</span><span class="o">.</span><span class="n">II</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ii</span><span class="p">)</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">JJmjj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">JJmjj</span><span class="p">,</span> <span class="n">ind0</span><span class="o">.</span><span class="n">JJ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">jj</span><span class="p">)</span>
        <span class="n">ind0</span><span class="o">.</span><span class="n">KKmkk</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind0</span><span class="o">.</span><span class="n">KKmkk</span><span class="p">,</span> <span class="n">ind0</span><span class="o">.</span><span class="n">KK</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">kk</span><span class="p">)</span></div>


<div class="viewcode-block" id="interactionList"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.interactionList">[docs]</a><span class="k">def</span> <span class="nf">interactionList</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">CJ</span><span class="p">,</span> <span class="n">CI</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span><span class="p">,</span>
                    <span class="n">s_src</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It finds the list of cells which each twig cell interacts.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    CJ     : int, index of source cell.</span>
<span class="sd">    CI     : int, index of target cell.</span>
<span class="sd">    theta  : float, Multipole-acceptance criterion (MAC).</span>
<span class="sd">    NCRIT  : int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                  structure.</span>
<span class="sd">    offTwg : array, pointer to the first element in the array P2P_list which</span>
<span class="sd">                    contains the P2P interaction list for each twig cell.</span>
<span class="sd">    offMlt : array, pointer to the first element in the array M2P_list which</span>
<span class="sd">                    contains the M2P interaction list for each twig cell.</span>
<span class="sd">    s_src  : int, position (index) in the surface-array of the surface that</span>
<span class="sd">                  contains the sources.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    offTwg : array, pointer to the first element in the P2P interaction list</span>
<span class="sd">                    for each twig cell.</span>
<span class="sd">    offMlt : array, pointer to the first element in the M2P interaction list</span>
<span class="sd">                    for each twig cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">NCRIT</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">)):</span>
                <span class="n">CC</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>  <span class="c1"># Points at child cell</span>
                <span class="n">dxi</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span> <span class="o">-</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CI</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span>
                <span class="n">dyi</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span> <span class="o">-</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CI</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span>
                <span class="n">dzi</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span> <span class="o">-</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CI</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dxi</span> <span class="o">*</span> <span class="n">dxi</span> <span class="o">+</span> <span class="n">dyi</span> <span class="o">*</span> <span class="n">dyi</span> <span class="o">+</span> <span class="n">dzi</span> <span class="o">*</span> <span class="n">dzi</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CI</span><span class="p">]</span><span class="o">.</span><span class="n">r</span> <span class="o">+</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span>
                        <span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">theta</span> <span class="o">*</span> <span class="n">r</span><span class="p">:</span>  <span class="c1"># Max distance between particles</span>
                    <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span> <span class="o">=</span> <span class="n">interactionList</span><span class="p">(</span>
                        <span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">CC</span><span class="p">,</span> <span class="n">CI</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">,</span> <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span><span class="p">,</span>
                        <span class="n">s_src</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">M2P_list</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="n">offMlt</span><span class="p">]</span> <span class="o">=</span> <span class="n">CC</span>
                    <span class="n">offMlt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">twig_cell</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">twig_array</span>
        <span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_list</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="n">offTwg</span><span class="p">]</span> <span class="o">=</span> <span class="n">twig_cell</span>
        <span class="n">offTwg</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span></div>


<div class="viewcode-block" id="generateList"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.generateList">[docs]</a><span class="k">def</span> <span class="nf">generateList</span><span class="p">(</span><span class="n">surf_array</span><span class="p">,</span> <span class="n">field_array</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loops over the surfaces to then compute the interactionList().</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surf_array : array, contains the surface classes of each region on the</span>
<span class="sd">                        surface.</span>
<span class="sd">    field_array: array, contains the Field classes of each region on the</span>
<span class="sd">                 surface.</span>
<span class="sd">    param      : class, parameters related to the surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Nsurf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">surf_array</span><span class="p">)</span>
    <span class="n">Nfield</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_array</span><span class="p">)</span>

    <span class="c1"># Allocate data</span>
    <span class="n">maxTwigSize</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsurf</span><span class="p">):</span>
        <span class="n">maxTwigSize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">twig</span><span class="p">),</span> <span class="n">maxTwigSize</span><span class="p">)</span>
        <span class="n">maxTwigSize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">),</span> <span class="n">maxTwigSize</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsurf</span><span class="p">):</span>
        <span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">P2P_list</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">Nsurf</span><span class="p">,</span> <span class="n">maxTwigSize</span> <span class="o">*</span> <span class="n">maxTwigSize</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">offsetTwigs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">Nsurf</span><span class="p">,</span>
             <span class="n">maxTwigSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">M2P_list</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">Nsurf</span><span class="p">,</span> <span class="n">maxTwigSize</span> <span class="o">*</span> <span class="n">maxTwigSize</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">offsetMlt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">Nsurf</span><span class="p">,</span>
             <span class="n">maxTwigSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">CI</span> <span class="ow">in</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">twig</span><span class="p">:</span>
            <span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CI</span><span class="p">]</span><span class="o">.</span><span class="n">M2P_list</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">Nsurf</span><span class="p">,</span> <span class="n">maxTwigSize</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">surf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">CI</span><span class="p">]</span><span class="o">.</span><span class="n">M2P_size</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nsurf</span><span class="p">,</span>
                                                          <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Generate list</span>
    <span class="c1"># Non-self interaction</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nfield</span><span class="p">):</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">S</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">field_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[:]</span>  <span class="c1"># Children surfaces</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Parent surface</span>

        <span class="k">for</span> <span class="n">s_tar</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>  <span class="c1"># Loop over surfaces</span>
            <span class="k">for</span> <span class="n">s_src</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">offTwg</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">offMlt</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">CI</span> <span class="ow">in</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">twig</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s_src</span> <span class="o">!=</span> <span class="n">s_tar</span><span class="p">:</span>  <span class="c1"># Non-self interaction</span>
                        <span class="n">CJ</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span> <span class="o">=</span> <span class="n">interactionList</span><span class="p">(</span>
                            <span class="n">surf_array</span><span class="p">[</span><span class="n">s_src</span><span class="p">],</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">],</span> <span class="n">CJ</span><span class="p">,</span> <span class="n">CI</span><span class="p">,</span>
                            <span class="n">param</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">,</span> <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span><span class="p">,</span> <span class="n">s_src</span><span class="p">)</span>
                        <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offTwg</span>
                        <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offMlt</span>
                        <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Self interaction</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsurf</span><span class="p">):</span>
        <span class="n">offTwg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">offMlt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">CI</span> <span class="ow">in</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">twig</span><span class="p">:</span>
            <span class="n">CJ</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span> <span class="o">=</span> <span class="n">interactionList</span><span class="p">(</span><span class="n">surf_array</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">CJ</span><span class="p">,</span>
                                             <span class="n">CI</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">,</span>
                                             <span class="n">offTwg</span><span class="p">,</span> <span class="n">offMlt</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="n">surf_array</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offTwg</span>
            <span class="n">surf_array</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offMlt</span>
            <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">s_tar</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsurf</span><span class="p">):</span>
        <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">xcSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nsurf</span><span class="p">,</span> <span class="n">maxTwigSize</span> <span class="o">*</span>
                                                <span class="n">maxTwigSize</span><span class="p">))</span>
        <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">ycSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nsurf</span><span class="p">,</span> <span class="n">maxTwigSize</span> <span class="o">*</span>
                                                <span class="n">maxTwigSize</span><span class="p">))</span>
        <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">zcSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nsurf</span><span class="p">,</span> <span class="n">maxTwigSize</span> <span class="o">*</span>
                                                <span class="n">maxTwigSize</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">s_src</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsurf</span><span class="p">):</span>
            <span class="n">M2P_size</span> <span class="o">=</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">surf_array</span><span class="p">[</span>
                <span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">twig</span><span class="p">)]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">M2P_list</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">M2P_size</span><span class="p">]:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">xcSort</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s_src</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span>
                    <span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span>
                <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">ycSort</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s_src</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span>
                    <span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span>
                <span class="n">surf_array</span><span class="p">[</span><span class="n">s_tar</span><span class="p">]</span><span class="o">.</span><span class="n">zcSort</span><span class="p">[</span><span class="n">s_src</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">surf_array</span><span class="p">[</span><span class="n">s_src</span><span class="p">]</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span>
                    <span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span></div>


<div class="viewcode-block" id="getMultipole"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.getMultipole">[docs]</a><span class="k">def</span> <span class="nf">getMultipole</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">mV</span><span class="p">,</span> <span class="n">mKx</span><span class="p">,</span> <span class="n">mKy</span><span class="p">,</span> <span class="n">mKz</span><span class="p">,</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It gets the multipole of the twig cells.</span>
<span class="sd">    (P2M)</span>

<span class="sd">    Note: In this context when we refer to mass we mean</span>
<span class="sd">                 mass  = (vector x gauss weights)</span>

<span class="sd">          where &#39;vector&#39; is the vector in the matrix-vector multiplication in</span>
<span class="sd">          the GMRES.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    Cells: array, it contains the cells information.</span>
<span class="sd">    C    : int, index of the cell in the Cells array.</span>
<span class="sd">    x    : array, x coordinate of the sources.</span>
<span class="sd">    y    : array, y coordinate of the sources.</span>
<span class="sd">    z    : array, z coordinate of the sources.</span>
<span class="sd">    mV   : array, mass of the source particle for the single layer potential</span>
<span class="sd">                  calculation.</span>
<span class="sd">    mKx  : array, mass of the source particle times  the &#39;x&#39; component of the</span>
<span class="sd">                  normal vector, for the double layer potential calculation.</span>
<span class="sd">    mKy  :array, mass of the source particle times  the &#39;y&#39; component of the</span>
<span class="sd">                  normal vector, for the double layer potential calculation.</span>
<span class="sd">    mKz  :array, mass of the source particle times  the &#39;z&#39; component of the</span>
<span class="sd">                  normal vector, for the double layer potential calculation.</span>
<span class="sd">    ind0 : class, it contains the indices related to the treecode computation.</span>
<span class="sd">    P    : int, order of the Taylor expansion.</span>
<span class="sd">    NCRIT: int, maximum number of boundary elements per twig box of tree</span>
<span class="sd">                structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">NCRIT</span><span class="p">):</span>

        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">M</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Initialize multipoles</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">)):</span>
                <span class="n">getMultipole</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">mV</span><span class="p">,</span> <span class="n">mKx</span><span class="p">,</span> <span class="n">mKy</span><span class="p">,</span>
                             <span class="n">mKz</span><span class="p">,</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">NCRIT</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">M</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Initialize multipoles</span>
        <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">l</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
        <span class="n">P2M</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">mV</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">mKx</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">mKy</span><span class="p">[</span><span class="n">l</span><span class="p">],</span>
            <span class="n">mKz</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span><span class="p">,</span> <span class="n">ind0</span><span class="o">.</span><span class="n">II</span><span class="p">,</span> <span class="n">ind0</span><span class="o">.</span><span class="n">JJ</span><span class="p">,</span>
            <span class="n">ind0</span><span class="o">.</span><span class="n">KK</span><span class="p">)</span></div>


<div class="viewcode-block" id="upwardSweep"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.upwardSweep">[docs]</a><span class="k">def</span> <span class="nf">upwardSweep</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">CC</span><span class="p">,</span> <span class="n">PC</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">JJ</span><span class="p">,</span> <span class="n">KK</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">combII</span><span class="p">,</span> <span class="n">combJJ</span><span class="p">,</span> <span class="n">combKK</span><span class="p">,</span>
                <span class="n">IImii</span><span class="p">,</span> <span class="n">JJmjj</span><span class="p">,</span> <span class="n">KKmkk</span><span class="p">,</span> <span class="n">index_small</span><span class="p">,</span> <span class="n">index_ptr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It calculates the M2M. Calculation of the multipole for non-twig cells .</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    Cells      : array, it contains the cells information.</span>
<span class="sd">    CC         : int, index of the child cell in the Cells array .</span>
<span class="sd">    PC         : int, index of the parent cell in the Cells array</span>
<span class="sd">    P          : int, order of the Taylor expansion.</span>
<span class="sd">    II         : list, multipole order in the x-direction for the treecode.</span>
<span class="sd">    JJ         : list, multipole order in the y-direction for the treecode.</span>
<span class="sd">    KK         : list, multipole order in the z-direction for the treecode.</span>
<span class="sd">    index      : list, pointers to the location of the mulipole of order i,j,k</span>
<span class="sd">                       in the multipole array.</span>
<span class="sd">    combII     : array, combinatory of (I, i) where I is the maximum i multipole.</span>
<span class="sd">    combJJ     : array, combinatory of (J, j) where J is the maximum j multipole.</span>
<span class="sd">    combKK     : array, combinatory of (K, k) where K is the maximum k multipole.</span>
<span class="sd">    IImii      : array, I-i where I is the maximum i multipole.</span>
<span class="sd">    JJmjj      : array, J-j where J is the maximum j multipole.</span>
<span class="sd">    KKmkk      : array, K-k where K is the maximum k multipole.</span>
<span class="sd">    index_small: list, pointers to the position of multipole order i, j, k</span>
<span class="sd">                       in the multipole array, organized in a 1D array which is</span>
<span class="sd">                       compressed with respect to index_large (does not consider</span>
<span class="sd">                       combinations of i,j,k which do not have a multipole).</span>
<span class="sd">    index_ptr  : list, pointer to index_small. Data in index_small is organized</span>
<span class="sd">                      in a i-major fashion (i,j,k), and index_ptr points at the</span>
<span class="sd">                      position in index_small where the order i changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">PC</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">PC</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">PC</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span>

    <span class="n">M2M</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">PC</span><span class="p">]</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">JJ</span><span class="p">,</span> <span class="n">KK</span><span class="p">,</span> <span class="n">combII</span><span class="p">,</span> <span class="n">combJJ</span><span class="p">,</span>
        <span class="n">combKK</span><span class="p">,</span> <span class="n">IImii</span><span class="p">,</span> <span class="n">JJmjj</span><span class="p">,</span> <span class="n">KKmkk</span><span class="p">,</span> <span class="n">index_small</span><span class="p">,</span> <span class="n">index_ptr</span><span class="p">)</span>
    <span class="n">M2M</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">PC</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">JJ</span><span class="p">,</span> <span class="n">KK</span><span class="p">,</span> <span class="n">combII</span><span class="p">,</span> <span class="n">combJJ</span><span class="p">,</span>
        <span class="n">combKK</span><span class="p">,</span> <span class="n">IImii</span><span class="p">,</span> <span class="n">JJmjj</span><span class="p">,</span> <span class="n">KKmkk</span><span class="p">,</span> <span class="n">index_small</span><span class="p">,</span> <span class="n">index_ptr</span><span class="p">)</span></div>


<div class="viewcode-block" id="M2P_sort"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.M2P_sort">[docs]</a><span class="k">def</span> <span class="nf">M2P_sort</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">K_aux</span><span class="p">,</span> <span class="n">V_aux</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">LorY</span><span class="p">,</span> <span class="n">timing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the far field contribution of the double and single layer</span>
<span class="sd">    potential using the sorted data.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    K_aux  : array, far field contribution to the double layer potential.</span>
<span class="sd">    V_aux  : array, far field contribution to the single layer potential.</span>
<span class="sd">    surf   : int, position of the source surface in the surface array.</span>
<span class="sd">    index  : list, pointers to the location of the mulipole of order i,j,k</span>
<span class="sd">                   in the multipole array.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    LorY   : int, Laplace (1) or Yukawa (2).</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    K_aux  : array, far field contribution to the double layer potential.</span>
<span class="sd">    V_aux  : array, far field contribution to the single layer potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">M2P_size</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">twig</span><span class="p">)]</span>
    <span class="n">MSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">*</span> <span class="n">M2P_size</span><span class="p">)</span>
    <span class="n">MdSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">*</span> <span class="n">M2P_size</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">M2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">M2P_size</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">MSort</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">:</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">+</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">M</span>
        <span class="n">MdSort</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">:</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">+</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span>

    <span class="n">multipole_sort</span><span class="p">(</span><span class="n">K_aux</span><span class="p">,</span> <span class="n">V_aux</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTarget</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarget</span><span class="p">,</span>
                   <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">MSort</span><span class="p">,</span> <span class="n">MdSort</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">xiSort</span><span class="p">,</span>
                   <span class="n">surfTar</span><span class="o">.</span><span class="n">yiSort</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">ziSort</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">xcSort</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span>
                   <span class="n">surfTar</span><span class="o">.</span><span class="n">ycSort</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">zcSort</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">index</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">P</span><span class="p">,</span>
                   <span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">LorY</span><span class="p">))</span>

    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_M2P</span> <span class="o">+=</span> <span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span>

    <span class="k">return</span> <span class="n">K_aux</span><span class="p">,</span> <span class="n">V_aux</span></div>


<div class="viewcode-block" id="M2PKt_sort"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.M2PKt_sort">[docs]</a><span class="k">def</span> <span class="nf">M2PKt_sort</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">Ktx_aux</span><span class="p">,</span> <span class="n">Kty_aux</span><span class="p">,</span> <span class="n">Ktz_aux</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span>
               <span class="n">LorY</span><span class="p">,</span> <span class="n">timing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the far field contribution of the adjoint double potential</span>
<span class="sd">    using the sorted data.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    Ktx_aux: array, x component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Kty_aux: array, y component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Ktz_aux: array, z component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    surf   : int, position of the source surface in the surface array.</span>
<span class="sd">    index  : list, pointers to the location of the mulipole of order i,j,k</span>
<span class="sd">                   in the multipole array.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    LorY   : int, Laplace (1) or Yukawa (2).</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Ktx_aux: array, x component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Kty_aux: array, y component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Ktz_aux: array, z component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">M2P_size</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">twig</span><span class="p">)]</span>
    <span class="n">MSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">*</span> <span class="n">M2P_size</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">M2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">M2P_size</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">MSort</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">:</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">+</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">M</span>

    <span class="n">multipoleKt_sort</span><span class="p">(</span><span class="n">Ktx_aux</span><span class="p">,</span> <span class="n">Kty_aux</span><span class="p">,</span> <span class="n">Ktz_aux</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTarget</span><span class="p">,</span>
                     <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarget</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">MSort</span><span class="p">,</span>
                     <span class="n">surfTar</span><span class="o">.</span><span class="n">xiSort</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">yiSort</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">ziSort</span><span class="p">,</span>
                     <span class="n">surfTar</span><span class="o">.</span><span class="n">xcSort</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">ycSort</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span>
                     <span class="n">surfTar</span><span class="o">.</span><span class="n">zcSort</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">index</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span>
                     <span class="nb">int</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">LorY</span><span class="p">))</span>

    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_M2P</span> <span class="o">+=</span> <span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span>

    <span class="k">return</span> <span class="n">Ktx_aux</span><span class="p">,</span> <span class="n">Kty_aux</span><span class="p">,</span> <span class="n">Ktz_aux</span></div>


<div class="viewcode-block" id="M2P_gpu"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.M2P_gpu">[docs]</a><span class="k">def</span> <span class="nf">M2P_gpu</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">K_gpu</span><span class="p">,</span> <span class="n">V_gpu</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">LorY</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span>
            <span class="n">kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the far field contribution of the double and single layer</span>
<span class="sd">    potential using the sorted data, on the GPU.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    K_gpu  : array, far field contribution to the double layer potential.</span>
<span class="sd">    V_gpu  : array, far field contribution to the single layer potential.</span>
<span class="sd">    ind0   : list, pointers to the location of the mulipole of order i,j,k</span>
<span class="sd">                   in the multipole array.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    LorY    int, Laplace (1) or Yukawa (2).</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>
<span class="sd">    kernel : pycuda source module.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    K_gpu  : array, far field contribution to the double layer potential.</span>
<span class="sd">    V_gpu  : array, far field contribution to the single layer potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">GPU</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

    <span class="n">REAL</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">REAL</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">M2P_size</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">twig</span><span class="p">)]</span>
    <span class="n">MSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">*</span> <span class="n">M2P_size</span><span class="p">)</span>
    <span class="n">MdSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">*</span> <span class="n">M2P_size</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">M2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">M2P_size</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">MSort</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">:</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">+</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">M</span>
        <span class="n">MdSort</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">:</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">+</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span>

    <span class="n">MDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">MSort</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">MdDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">MdSort</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>

    <span class="c1"># GPU arrays are flattened, need to point to first element</span>
    <span class="n">ptr_offset</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                            <span class="p">)</span>  <span class="c1"># Pointer to first element of offset arrays</span>
    <span class="n">ptr_list</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                          <span class="p">)</span>  <span class="c1"># Pointer to first element in lists arrays</span>

    <span class="n">GSZ</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">)</span> <span class="o">/</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">))</span>  <span class="c1"># CUDA grid size</span>
    <span class="n">multipole_gpu</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;M2P&quot;</span><span class="p">)</span>

    <span class="n">multipole_gpu</span><span class="p">(</span><span class="n">K_gpu</span><span class="p">,</span>
                  <span class="n">V_gpu</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">offMltDev</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarDev</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">xcDev</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">ycDev</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">zcDev</span><span class="p">,</span>
                  <span class="n">MDev</span><span class="p">,</span>
                  <span class="n">MdDev</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">xiDev</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">yiDev</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">ziDev</span><span class="p">,</span>
                  <span class="n">ind0</span><span class="o">.</span><span class="n">indexDev</span><span class="p">,</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_offset</span><span class="p">),</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_list</span><span class="p">),</span>
                  <span class="n">REAL</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">),</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BlocksPerTwig</span><span class="p">),</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">),</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">LorY</span><span class="p">),</span>
                  <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">GSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_M2P</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="k">return</span> <span class="n">K_gpu</span><span class="p">,</span> <span class="n">V_gpu</span></div>


<div class="viewcode-block" id="M2PKt_gpu"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.M2PKt_gpu">[docs]</a><span class="k">def</span> <span class="nf">M2PKt_gpu</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">Ktx_gpu</span><span class="p">,</span> <span class="n">Kty_gpu</span><span class="p">,</span> <span class="n">Ktz_gpu</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span>
              <span class="n">LorY</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the far field contribution of the adjoint double potential</span>
<span class="sd">    using the sorted data, on the GPU.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    Ktx_gpu: array, x component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Kty_gpu: array, y component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Ktz_gpu: array, z component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    surf   : int, position of the source surface in the surface array.</span>
<span class="sd">    ind0   : list, pointers to the location of the mulipole of order i,j,k</span>
<span class="sd">                   in the multipole array.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    LorY   : int, Laplace (1) or Yukawa (2).</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>
<span class="sd">    kernel : pycuda source module.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Ktx_gpu: array, x component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Kty_gpu: array, y component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Ktz_gpu: array, z component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">GPU</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

    <span class="n">REAL</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">REAL</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">M2P_size</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetMlt</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">twig</span><span class="p">)]</span>
    <span class="n">MSort</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">*</span> <span class="n">M2P_size</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">M2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">M2P_size</span><span class="p">]:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">MSort</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">:</span><span class="n">i</span> <span class="o">*</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span> <span class="o">+</span> <span class="n">param</span><span class="o">.</span><span class="n">Nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">C</span><span class="p">]</span><span class="o">.</span><span class="n">M</span>

    <span class="n">MDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">MSort</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>

    <span class="c1"># GPU arrays are flattened, need to point to first element</span>
    <span class="n">ptr_offset</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                            <span class="p">)</span>  <span class="c1"># Pointer to first element of offset arrays</span>
    <span class="n">ptr_list</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                          <span class="p">)</span>  <span class="c1"># Pointer to first element in lists arrays</span>

    <span class="n">GSZ</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">)</span> <span class="o">/</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">))</span>  <span class="c1"># CUDA grid size</span>
    <span class="n">multipoleKt_gpu</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;M2PKt&quot;</span><span class="p">)</span>

    <span class="n">multipoleKt_gpu</span><span class="p">(</span><span class="n">Ktx_gpu</span><span class="p">,</span>
                    <span class="n">Kty_gpu</span><span class="p">,</span>
                    <span class="n">Ktz_gpu</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">offMltDev</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarDev</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">xcDev</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">ycDev</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">zcDev</span><span class="p">,</span>
                    <span class="n">MDev</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">xiDev</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">yiDev</span><span class="p">,</span>
                    <span class="n">surfTar</span><span class="o">.</span><span class="n">ziDev</span><span class="p">,</span>
                    <span class="n">ind0</span><span class="o">.</span><span class="n">indexDev</span><span class="p">,</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_offset</span><span class="p">),</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_list</span><span class="p">),</span>
                    <span class="n">REAL</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">),</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BlocksPerTwig</span><span class="p">),</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">),</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">LorY</span><span class="p">),</span>
                    <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">GSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_M2P</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="k">return</span> <span class="n">Ktx_gpu</span><span class="p">,</span> <span class="n">Kty_gpu</span><span class="p">,</span> <span class="n">Ktz_gpu</span></div>


<div class="viewcode-block" id="P2P_sort"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.P2P_sort">[docs]</a><span class="k">def</span> <span class="nf">P2P_sort</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mKc</span><span class="p">,</span> <span class="n">mVc</span><span class="p">,</span> <span class="n">K_aux</span><span class="p">,</span> <span class="n">V_aux</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span>
             <span class="n">LorY</span><span class="p">,</span> <span class="n">K_diag</span><span class="p">,</span> <span class="n">V_diag</span><span class="p">,</span> <span class="n">IorE</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">timing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the near field contribution of the double and single layer</span>
<span class="sd">    potential using the sorted data and adds it to the far field contribution</span>
<span class="sd">    given as an input.</span>

<span class="sd">    Note: In this context when we refer to mass we mean</span>
<span class="sd">                 mass       = (vector x gauss weights)</span>
<span class="sd">                 mass-clean = (vector)</span>

<span class="sd">          where &#39;vector&#39; is the vector in the matrix-vector multiplication in</span>
<span class="sd">          the GMRES.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    m      : array, mass of the source particle for the single layer potential</span>
<span class="sd">                    calculation.</span>
<span class="sd">    mx     : array, mass of the source particle times  the &#39;x&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    my     : array, mass of the source particle times  the &#39;y&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    mz     : array, mass of the source particle times  the &#39;z&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    mKc    : array, mass-clean of the source particle for the double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    mVc    : array, mass-clean of the source particle for the double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    K_aux  : array, far field contribution to the double layer potential.</span>
<span class="sd">    V_aux  : array, far field contribution to the single layer potential.</span>
<span class="sd">    surf   : int, position of the source surface in the surface array.</span>
<span class="sd">    K_diag : array, diagonal elements of the double layer integral operator.</span>
<span class="sd">    V_diag : array, diagonal elements of the single layer integral operator.</span>
<span class="sd">    IorE   : int, internal (1) or external (2).</span>
<span class="sd">    L      : float, representative distance of the triangles. (sqrt{2*Area})</span>
<span class="sd">    w      : array, gauss points.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    K_aux  : array, far plus near field contribution to the double layer</span>
<span class="sd">                    potential.</span>
<span class="sd">    V_aux  : array, far plus near field contribution to the single layer</span>
<span class="sd">                    potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">s_xj</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">xjSort</span>
    <span class="n">s_yj</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">yjSort</span>
    <span class="n">s_zj</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">zjSort</span>

    <span class="n">xt</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">xiSort</span>
    <span class="n">yt</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">yiSort</span>
    <span class="n">zt</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">ziSort</span>

    <span class="n">tri</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">/</span> <span class="n">param</span><span class="o">.</span><span class="n">K</span>  <span class="c1"># Triangle</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">%</span> <span class="n">param</span><span class="o">.</span><span class="n">K</span>  <span class="c1"># Gauss point</span>

    <span class="n">aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">direct_sort</span><span class="p">(</span>
        <span class="n">K_aux</span><span class="p">,</span> <span class="n">V_aux</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">LorY</span><span class="p">),</span> <span class="n">K_diag</span><span class="p">,</span> <span class="n">V_diag</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">IorE</span><span class="p">),</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">surfSrc</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">surfSrc</span><span class="o">.</span><span class="n">triangleSort</span><span class="p">[:]]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">tri</span><span class="p">),</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">yi</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">zi</span><span class="p">,</span> <span class="n">s_xj</span><span class="p">,</span> <span class="n">s_yj</span><span class="p">,</span> <span class="n">s_zj</span><span class="p">,</span>
        <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">zt</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mKc</span><span class="p">,</span> <span class="n">mVc</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span>
        <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTarget</span><span class="p">,</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarget</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">offsetSource</span><span class="p">,</span>
        <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">target</span><span class="p">),</span>
        <span class="n">surfSrc</span><span class="o">.</span><span class="n">AreaSort</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">sglInt_intSort</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">sglInt_extSort</span><span class="p">,</span>
        <span class="n">surfSrc</span><span class="o">.</span><span class="n">xk</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">wk</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">Xsk</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">Wsk</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span>
        <span class="n">param</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aux</span><span class="p">)</span>

    <span class="n">timing</span><span class="o">.</span><span class="n">AI_int</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_an</span> <span class="o">+=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_P2P</span> <span class="o">+=</span> <span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span>

    <span class="k">return</span> <span class="n">K_aux</span><span class="p">,</span> <span class="n">V_aux</span></div>


<div class="viewcode-block" id="P2PKt_sort"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.P2PKt_sort">[docs]</a><span class="k">def</span> <span class="nf">P2PKt_sort</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mKc</span><span class="p">,</span> <span class="n">Ktx_aux</span><span class="p">,</span> <span class="n">Kty_aux</span><span class="p">,</span> <span class="n">Ktz_aux</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span> <span class="n">LorY</span><span class="p">,</span>
               <span class="n">w</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">timing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the near field contribution of the double and single layer</span>
<span class="sd">    potential using the sorted data and adds it to the far field contribution</span>
<span class="sd">    given as an input.</span>

<span class="sd">    Note: In this context when we refer to mass we mean</span>
<span class="sd">                 mass       = (vector x gauss weights)</span>
<span class="sd">                 mass-clean = (vector)</span>

<span class="sd">          where &#39;vector&#39; is the vector in the matrix-vector multiplication in</span>
<span class="sd">          the GMRES.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    m      : array, mass of the source particle for the adjoint double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    mKc    : array, mass-clean of the source particle for the adjoint double</span>
<span class="sd">                    layer potential calculation.</span>
<span class="sd">    Ktx_aux: array, x component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Kty_aux: array, y component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Ktz_aux: array, z component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    surf   : int, position of the source surface in the surface array.</span>
<span class="sd">    LorY   : int, Laplace (1) or Yukawa (2).</span>
<span class="sd">    w      : array, gauss points.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Ktx_aux: array, x component of the far plus near field contribution to the</span>
<span class="sd">                    adjoint double layer potential.</span>
<span class="sd">    Kty_aux: array, y component of the far plus near field contribution to the</span>
<span class="sd">                    adjoint double layer potential.</span>
<span class="sd">    Ktz_aux: array, z component of the far plus near field contribution to the</span>
<span class="sd">                    adjoint double layer potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">s_xj</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">xjSort</span>
    <span class="n">s_yj</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">yjSort</span>
    <span class="n">s_zj</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">zjSort</span>

    <span class="n">xt</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">xiSort</span>
    <span class="n">yt</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">yiSort</span>
    <span class="n">zt</span> <span class="o">=</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">ziSort</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">sortSource</span> <span class="o">%</span> <span class="n">param</span><span class="o">.</span><span class="n">K</span>  <span class="c1"># Gauss point</span>

    <span class="n">aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">directKt_sort</span><span class="p">(</span><span class="n">Ktx_aux</span><span class="p">,</span> <span class="n">Kty_aux</span><span class="p">,</span> <span class="n">Ktz_aux</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">LorY</span><span class="p">),</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">surfSrc</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">surfSrc</span><span class="o">.</span><span class="n">triangleSort</span><span class="p">[:]]),</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">s_xj</span><span class="p">,</span> <span class="n">s_yj</span><span class="p">,</span> <span class="n">s_zj</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">zt</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mKc</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTarget</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarget</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">offsetSource</span><span class="p">,</span>
                  <span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">AreaSort</span><span class="p">,</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">Xsk</span><span class="p">,</span>
                  <span class="n">surfSrc</span><span class="o">.</span><span class="n">Wsk</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">aux</span><span class="p">)</span>

    <span class="n">timing</span><span class="o">.</span><span class="n">AI_int</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_an</span> <span class="o">+=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_P2P</span> <span class="o">+=</span> <span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span>

    <span class="k">return</span> <span class="n">Ktx_aux</span><span class="p">,</span> <span class="n">Kty_aux</span><span class="p">,</span> <span class="n">Ktz_aux</span></div>


<div class="viewcode-block" id="P2P_gpu"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.P2P_gpu">[docs]</a><span class="k">def</span> <span class="nf">P2P_gpu</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mKc</span><span class="p">,</span> <span class="n">mVc</span><span class="p">,</span> <span class="n">K_gpu</span><span class="p">,</span> <span class="n">V_gpu</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span>
            <span class="n">LorY</span><span class="p">,</span> <span class="n">K_diag</span><span class="p">,</span> <span class="n">IorE</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the near field contribution of the double and single layer</span>
<span class="sd">    potential using the sorted data and adds it to the far field contribution</span>
<span class="sd">    given as an input, on the GPU.</span>

<span class="sd">    Note: In this context when we refer to mass we mean</span>
<span class="sd">                 mass       = (vector x gauss weights)</span>
<span class="sd">                 mass-clean = (vector)</span>

<span class="sd">          where &#39;vector&#39; is the vector in the matrix-vector multiplication in</span>
<span class="sd">          the GMRES.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    m      : array, mass of the source particle for the single layer potential</span>
<span class="sd">                    calculation.</span>
<span class="sd">    mx     : array, mass of the source particle times  the &#39;x&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    my     : array, mass of the source particle times  the &#39;y&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    mz     : array, mass of the source particle times  the &#39;z&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    mKc    : array, mass-clean of the source particle for the double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    mVc    : array, mass-clean of the source particle for the double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    K_gpu  : array, far field contribution to the double layer potential.</span>
<span class="sd">    V_gpu  : array, far field contribution to the single layer potential.</span>
<span class="sd">    surf   : int, position of the source surface in the surface array.</span>
<span class="sd">    K_diag : array, diagonal elements of the double layer integral operator.</span>
<span class="sd">    IorE   : int, internal (1) or external (2).</span>
<span class="sd">    L      : float, representative distance of the triangles. (sqrt{2*Area})</span>
<span class="sd">    w      : array, gauss points.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>
<span class="sd">    kernel : pycuda source module.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    K_gpu  : array, far plus near field contribution to the double layer</span>
<span class="sd">                    potential.</span>
<span class="sd">    V_gpu  : array, far plus near field contribution to the single layer</span>
<span class="sd">                    potential.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">GPU</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">REAL</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">REAL</span>
    <span class="n">mDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">mxDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">myDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">my</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">mzDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">mz</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">mKcDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">mKc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">mVcDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">mVc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_trans</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">GSZ</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">)</span> <span class="o">/</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">))</span>  <span class="c1"># CUDA grid size</span>
    <span class="n">direct_gpu</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;P2P&quot;</span><span class="p">)</span>
    <span class="n">AI_int</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

    <span class="c1"># GPU arrays are flattened, need to point to first element</span>
    <span class="n">ptr_offset</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                            <span class="p">)</span>  <span class="c1"># Pointer to first element of offset arrays</span>
    <span class="n">ptr_list</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                          <span class="p">)</span>  <span class="c1"># Pointer to first element in lists arrays</span>

    <span class="c1"># Check if internal or external to send correct singular integral</span>
    <span class="k">if</span> <span class="n">IorE</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sglInt</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">sglInt_intDev</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sglInt</span> <span class="o">=</span> <span class="n">surfSrc</span><span class="o">.</span><span class="n">sglInt_extDev</span>

    <span class="n">direct_gpu</span><span class="p">(</span><span class="n">K_gpu</span><span class="p">,</span>
               <span class="n">V_gpu</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">offSrcDev</span><span class="p">,</span>
               <span class="n">surfTar</span><span class="o">.</span><span class="n">offTwgDev</span><span class="p">,</span>
               <span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_lstDev</span><span class="p">,</span>
               <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarDev</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">kDev</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">xjDev</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">yjDev</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">zjDev</span><span class="p">,</span>
               <span class="n">mDev</span><span class="p">,</span>
               <span class="n">mxDev</span><span class="p">,</span>
               <span class="n">myDev</span><span class="p">,</span>
               <span class="n">mzDev</span><span class="p">,</span>
               <span class="n">mKcDev</span><span class="p">,</span>
               <span class="n">mVcDev</span><span class="p">,</span>
               <span class="n">surfTar</span><span class="o">.</span><span class="n">xiDev</span><span class="p">,</span>
               <span class="n">surfTar</span><span class="o">.</span><span class="n">yiDev</span><span class="p">,</span>
               <span class="n">surfTar</span><span class="o">.</span><span class="n">ziDev</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">AreaDev</span><span class="p">,</span>
               <span class="n">sglInt</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">vertexDev</span><span class="p">,</span>
               <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_offset</span><span class="p">),</span>
               <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_list</span><span class="p">),</span>
               <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">LorY</span><span class="p">),</span>
               <span class="n">REAL</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">),</span>
               <span class="n">REAL</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">threshold</span><span class="p">),</span>
               <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BlocksPerTwig</span><span class="p">),</span>
               <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">),</span>
               <span class="n">REAL</span><span class="p">(</span><span class="n">K_diag</span><span class="p">),</span>
               <span class="n">AI_int</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">XskDev</span><span class="p">,</span>
               <span class="n">surfSrc</span><span class="o">.</span><span class="n">WskDev</span><span class="p">,</span>
               <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
               <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">GSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_P2P</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">AI_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">AI_aux</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">from_device</span><span class="p">(</span><span class="n">AI_int</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">AI_int</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">AI_aux</span><span class="p">[</span><span class="n">surfTar</span><span class="o">.</span><span class="n">unsort</span><span class="p">])</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_trans</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="k">return</span> <span class="n">K_gpu</span><span class="p">,</span> <span class="n">V_gpu</span></div>


<div class="viewcode-block" id="P2PKt_gpu"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.P2PKt_gpu">[docs]</a><span class="k">def</span> <span class="nf">P2PKt_gpu</span><span class="p">(</span><span class="n">surfSrc</span><span class="p">,</span> <span class="n">surfTar</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mKtc</span><span class="p">,</span> <span class="n">Ktx_gpu</span><span class="p">,</span> <span class="n">Kty_gpu</span><span class="p">,</span> <span class="n">Ktz_gpu</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span> <span class="n">LorY</span><span class="p">,</span>
              <span class="n">w</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the near field contribution of the double and single layer</span>
<span class="sd">    potential using the sorted data and adds it to the far field contribution</span>
<span class="sd">    given as an input, on the GPU.</span>

<span class="sd">    Note: In this context when we refer to mass we mean</span>

<span class="sd">                 mass       = (vector x gauss weights)</span>
<span class="sd">                 mass-clean = (vector)</span>

<span class="sd">          where &#39;vector&#39; is the vector in the matrix-vector multiplication in</span>
<span class="sd">          the GMRES.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    surfSrc: class, source surface, the one that contains the gauss points.</span>
<span class="sd">    surfTar: class, target surface, the one that contains the collocation</span>
<span class="sd">                    points.</span>
<span class="sd">    m      : array, mass of the source particle for the adjoint double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    mKc    : array, mass-clean of the source particle for the adjoint double</span>
<span class="sd">                    layer potential calculation.</span>
<span class="sd">    Ktx_gpu: array, x component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Kty_gpu: array, y component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    Ktz_gpu: array, z component of the far field contribution to the adjoint</span>
<span class="sd">                    double layer potential.</span>
<span class="sd">    surf   : int, position of the source surface in the surface array.</span>
<span class="sd">    LorY   : int, Laplace (1) or Yukawa (2).</span>
<span class="sd">    w      : array, gauss points.</span>
<span class="sd">    param  : class, parameters related to the surface.</span>
<span class="sd">    timing : class, it contains timing information for different parts of</span>
<span class="sd">                    the code.</span>
<span class="sd">    kernel : pycuda source module.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Ktx_gpu: array, x component of the far plus near field contribution to the</span>
<span class="sd">                    adjoint double layer potential.</span>
<span class="sd">    Kty_gpu: array, y component of the far plus near field contribution to the</span>
<span class="sd">                    adjoint double layer potential.</span>
<span class="sd">    Ktz_gpu: array, z component of the far plus near field contribution to the</span>
<span class="sd">                    adjoint double layer potential.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">GPU</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="n">toc</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">REAL</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">REAL</span>
    <span class="n">mDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">mKtcDev</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">mKtc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">REAL</span><span class="p">))</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_trans</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">GSZ</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">)</span> <span class="o">/</span> <span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">))</span>  <span class="c1"># CUDA grid size</span>
    <span class="n">directKt_gpu</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;P2PKt&quot;</span><span class="p">)</span>
    <span class="n">AI_int</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

    <span class="c1"># GPU arrays are flattened, need to point to first element</span>
    <span class="n">ptr_offset</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">offsetTwigs</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                            <span class="p">)</span>  <span class="c1"># Pointer to first element of offset arrays</span>
    <span class="n">ptr_list</span> <span class="o">=</span> <span class="n">surf</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_list</span><span class="p">[</span><span class="n">surf</span><span class="p">]</span>
                          <span class="p">)</span>  <span class="c1"># Pointer to first element in lists arrays</span>

    <span class="n">directKt_gpu</span><span class="p">(</span><span class="n">Ktx_gpu</span><span class="p">,</span>
                 <span class="n">Kty_gpu</span><span class="p">,</span>
                 <span class="n">Ktz_gpu</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">offSrcDev</span><span class="p">,</span>
                 <span class="n">surfTar</span><span class="o">.</span><span class="n">offTwgDev</span><span class="p">,</span>
                 <span class="n">surfTar</span><span class="o">.</span><span class="n">P2P_lstDev</span><span class="p">,</span>
                 <span class="n">surfTar</span><span class="o">.</span><span class="n">sizeTarDev</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">kDev</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">xjDev</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">yjDev</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">zjDev</span><span class="p">,</span>
                 <span class="n">mDev</span><span class="p">,</span>
                 <span class="n">mKtcDev</span><span class="p">,</span>
                 <span class="n">surfTar</span><span class="o">.</span><span class="n">xiDev</span><span class="p">,</span>
                 <span class="n">surfTar</span><span class="o">.</span><span class="n">yiDev</span><span class="p">,</span>
                 <span class="n">surfTar</span><span class="o">.</span><span class="n">ziDev</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">AreaDev</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">vertexDev</span><span class="p">,</span>
                 <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_offset</span><span class="p">),</span>
                 <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">ptr_list</span><span class="p">),</span>
                 <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">LorY</span><span class="p">),</span>
                 <span class="n">REAL</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kappa</span><span class="p">),</span>
                 <span class="n">REAL</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">threshold</span><span class="p">),</span>
                 <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BlocksPerTwig</span><span class="p">),</span>
                 <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">),</span>
                 <span class="n">AI_int</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">XskDev</span><span class="p">,</span>
                 <span class="n">surfSrc</span><span class="o">.</span><span class="n">WskDev</span><span class="p">,</span>
                 <span class="n">block</span><span class="o">=</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">BSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">GSZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_P2P</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="n">tic</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">AI_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">AI_aux</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">from_device</span><span class="p">(</span><span class="n">AI_int</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">Nround</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">AI_int</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">AI_aux</span><span class="p">[</span><span class="n">surfTar</span><span class="o">.</span><span class="n">unsort</span><span class="p">])</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
    <span class="n">toc</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">timing</span><span class="o">.</span><span class="n">time_trans</span> <span class="o">+=</span> <span class="n">tic</span><span class="o">.</span><span class="n">time_till</span><span class="p">(</span><span class="n">toc</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-3</span>

    <span class="k">return</span> <span class="n">Ktx_gpu</span><span class="p">,</span> <span class="n">Kty_gpu</span><span class="p">,</span> <span class="n">Ktz_gpu</span></div>


<div class="viewcode-block" id="M2P_nonvec"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.M2P_nonvec">[docs]</a><span class="k">def</span> <span class="nf">M2P_nonvec</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">CJ</span><span class="p">,</span> <span class="n">xq</span><span class="p">,</span> <span class="n">Kval</span><span class="p">,</span> <span class="n">Vval</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">par_reac</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">time_M2P</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the far field contribution of the double and single layer</span>
<span class="sd">    potential without doing the assumption that all the particles in the same</span>
<span class="sd">    twig cell have the same interaction list.</span>

<span class="sd">    This is used for the calculation for the reaction potential where the</span>
<span class="sd">    targets are the point-charges location.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    Cells   : array, cells of the tree.</span>
<span class="sd">    CJ      : int, index of the source cell.</span>
<span class="sd">    xq      : array, postion of the point charges.</span>
<span class="sd">    Kval  : array, far field contribution to the double layer potential.</span>
<span class="sd">    Vval  : array, far field contribution to the single layer potential.</span>
<span class="sd">    index   : list, pointers to the location of the mulipole of order i,j,k</span>
<span class="sd">                    in the multipole array.</span>
<span class="sd">    par_reac: class, fine parameters related to the surface.</span>
<span class="sd">    source  : list, P2P interaction list, which is a list of the cells that</span>
<span class="sd">                    each charge-point interacts by P2P.</span>
<span class="sd">    time_M2P: real, timed consumed in compute M2P_nonvec function.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Kval  : array, far field contribution to the double layer potential.</span>
<span class="sd">    Vval  : array, far field contribution to the single layer potential.</span>
<span class="sd">    source  : list, P2P interaction list, which is a list of the cells that</span>
<span class="sd">                    each charge-point interacts.</span>
<span class="sd">    time_M2P: real, time consumed in compute M2P_nonvec function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">ntarget</span> <span class="o">&gt;=</span> <span class="n">par_reac</span><span class="o">.</span><span class="n">NCRIT</span><span class="p">):</span>  <span class="c1"># if not a twig</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">nchild</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">)):</span>
                <span class="n">CC</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>  <span class="c1"># Points at child cell</span>
                <span class="n">dxi</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span> <span class="o">-</span> <span class="n">xq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dyi</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span> <span class="o">-</span> <span class="n">xq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">dzi</span> <span class="o">=</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span> <span class="o">-</span> <span class="n">xq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dxi</span> <span class="o">*</span> <span class="n">dxi</span> <span class="o">+</span> <span class="n">dyi</span> <span class="o">*</span> <span class="n">dyi</span> <span class="o">+</span> <span class="n">dzi</span> <span class="o">*</span> <span class="n">dzi</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">Cells</span><span class="p">[</span>
                        <span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">r</span> <span class="o">&gt;</span> <span class="n">par_reac</span><span class="o">.</span><span class="n">theta</span> <span class="o">*</span> <span class="n">r</span><span class="p">:</span>  <span class="c1"># Max distance between particles</span>
                    <span class="n">Kval</span><span class="p">,</span> <span class="n">Vval</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">time_M2P</span> <span class="o">=</span> <span class="n">M2P_nonvec</span><span class="p">(</span>
                        <span class="n">Cells</span><span class="p">,</span> <span class="n">CC</span><span class="p">,</span> <span class="n">xq</span><span class="p">,</span> <span class="n">Kval</span><span class="p">,</span> <span class="n">Vval</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">par_reac</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span>
                        <span class="n">time_M2P</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="n">dxi</span> <span class="o">=</span> <span class="n">xq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">xc</span>
                    <span class="n">dyi</span> <span class="o">=</span> <span class="n">xq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">yc</span>
                    <span class="n">dzi</span> <span class="o">=</span> <span class="n">xq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">zc</span>

                    <span class="n">K_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">V_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">dxi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dxi</span><span class="p">])</span>
                    <span class="n">dyi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dyi</span><span class="p">])</span>
                    <span class="n">dzi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dzi</span><span class="p">])</span>
                    <span class="n">LorY</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">multipole_c</span><span class="p">(</span><span class="n">K_aux</span><span class="p">,</span> <span class="n">V_aux</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">Cells</span><span class="p">[</span><span class="n">CC</span><span class="p">]</span><span class="o">.</span><span class="n">Md</span><span class="p">,</span> <span class="n">dxi</span><span class="p">,</span>
                                <span class="n">dyi</span><span class="p">,</span> <span class="n">dzi</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">par_reac</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">par_reac</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span>
                                <span class="nb">int</span><span class="p">(</span><span class="n">par_reac</span><span class="o">.</span><span class="n">Nm</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">LorY</span><span class="p">))</span>

                    <span class="n">Kval</span> <span class="o">+=</span> <span class="n">K_aux</span>
                    <span class="n">Vval</span> <span class="o">+=</span> <span class="n">V_aux</span>
                    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="n">time_M2P</span> <span class="o">+=</span> <span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Else on a twig cell</span>
        <span class="n">source</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">Cells</span><span class="p">[</span><span class="n">CJ</span><span class="p">]</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Kval</span><span class="p">,</span> <span class="n">Vval</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">time_M2P</span></div>


<div class="viewcode-block" id="P2P_nonvec"><a class="viewcode-back" href="../../../source/pygbe.tree.html#pygbe.tree.FMMutils.P2P_nonvec">[docs]</a><span class="k">def</span> <span class="nf">P2P_nonvec</span><span class="p">(</span><span class="n">Cells</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mKc</span><span class="p">,</span> <span class="n">mVc</span><span class="p">,</span> <span class="n">xq</span><span class="p">,</span> <span class="n">Kval</span><span class="p">,</span> <span class="n">Vval</span><span class="p">,</span> <span class="n">IorE</span><span class="p">,</span>
               <span class="n">par_reac</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">AI_int</span><span class="p">,</span> <span class="n">time_P2P</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It computes the near field contribution of the double and single layer</span>
<span class="sd">    potential and adds it to the far field contribution given as an input.</span>
<span class="sd">    In this case we don&#39;t do the assumption that all the particles in the same</span>
<span class="sd">    twig cell have the same interaction list.</span>

<span class="sd">    This is used for the calculation for the reaction potential where the</span>
<span class="sd">    targets are the point-charges location.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ----------</span>
<span class="sd">    Cells   : array, cells of the tree.</span>
<span class="sd">    surface : class, surface where we are computing the P2P_nonvec.</span>
<span class="sd">    m       : array, mass of the source particle for the single layer potential</span>
<span class="sd">                    calculation.</span>
<span class="sd">    mx      : array, mass of the source particle times  the &#39;x&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    my      : array, mass of the source particle times  the &#39;y&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    mz      : array, mass of the source particle times  the &#39;z&#39; component of the</span>
<span class="sd">                    normal vector, for the double layer potential calculation.</span>
<span class="sd">    mKc     : array, mass-clean of the source particle for the double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    mVc     : array, mass-clean of the source particle for the double layer</span>
<span class="sd">                    potential calculation.</span>
<span class="sd">    xq      : array, postion of the point charges.</span>
<span class="sd">    Kval  : array, far field contribution to the double layer potential.</span>
<span class="sd">    Vval  : array, far field contribution to the single layer potential.</span>
<span class="sd">    IorE    : int, internal (1) or external (2).</span>
<span class="sd">    par_reac: class, fine parameters related to the surface.</span>
<span class="sd">    w       : array, gauss points.</span>
<span class="sd">    source  : list, P2P interaction list, which is a list of the cells that</span>
<span class="sd">                    each charge-point interacts.</span>
<span class="sd">    AI_int  : int, counter of the amount of near singular integrals solved.</span>
<span class="sd">    time_P2P: real, timed consumed in compute P2P_nonvec function.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Kval   : array, far plus near field contribution to the double layer</span>
<span class="sd">                    potential.</span>
<span class="sd">    Vval  : array, far plus near field contribution to the single layer</span>
<span class="sd">                    potential.</span>
<span class="sd">    AI_int  : int, counter of the amount of near singular integrals solved.</span>
<span class="sd">    time_P2P: real, timed consumed in compute P2P_nonvec function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">LorY</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
    <span class="n">s_xj</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">xj</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_yj</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">yj</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_zj</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">zj</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_mx</span> <span class="o">=</span> <span class="n">mx</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_my</span> <span class="o">=</span> <span class="n">my</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_mz</span> <span class="o">=</span> <span class="n">mz</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_mKc</span> <span class="o">=</span> <span class="n">mKc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">s_mVc</span> <span class="o">=</span> <span class="n">mVc</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>

    <span class="n">tri</span> <span class="o">=</span> <span class="n">source</span> <span class="o">/</span> <span class="n">par_reac</span><span class="o">.</span><span class="n">K</span>  <span class="c1"># Triangle</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">source</span> <span class="o">%</span> <span class="n">par_reac</span><span class="o">.</span><span class="n">K</span>  <span class="c1"># Gauss point</span>

    <span class="n">K_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">V_aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">xq_arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xq</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="n">yq_arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xq</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">zq_arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xq</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

    <span class="n">aux</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">K_diag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">V_diag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">direct_c</span><span class="p">(</span><span class="n">K_aux</span><span class="p">,</span>
             <span class="n">V_aux</span><span class="p">,</span>
             <span class="nb">int</span><span class="p">(</span><span class="n">LorY</span><span class="p">),</span>
             <span class="n">K_diag</span><span class="p">,</span>
             <span class="n">V_diag</span><span class="p">,</span>
             <span class="nb">int</span><span class="p">(</span><span class="n">IorE</span><span class="p">),</span>
             <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">surface</span><span class="o">.</span><span class="n">vertex</span><span class="p">[</span><span class="n">surface</span><span class="o">.</span><span class="n">triangle</span><span class="p">[:]]),</span>
             <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">tri</span><span class="p">),</span>
             <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">xi</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">yi</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">zi</span><span class="p">,</span>
             <span class="n">s_xj</span><span class="p">,</span>
             <span class="n">s_yj</span><span class="p">,</span>
             <span class="n">s_zj</span><span class="p">,</span>
             <span class="n">xq_arr</span><span class="p">,</span>
             <span class="n">yq_arr</span><span class="p">,</span>
             <span class="n">zq_arr</span><span class="p">,</span>
             <span class="n">s_m</span><span class="p">,</span>
             <span class="n">s_mx</span><span class="p">,</span>
             <span class="n">s_my</span><span class="p">,</span>
             <span class="n">s_mz</span><span class="p">,</span>
             <span class="n">s_mKc</span><span class="p">,</span>
             <span class="n">s_mVc</span><span class="p">,</span>
             <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                 <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">area</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">sglInt_int</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">sglInt_ext</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">xk</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">wk</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">Xsk</span><span class="p">,</span>
             <span class="n">surface</span><span class="o">.</span><span class="n">Wsk</span><span class="p">,</span>
             <span class="n">par_reac</span><span class="o">.</span><span class="n">kappa</span><span class="p">,</span>
             <span class="n">par_reac</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
             <span class="n">par_reac</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
             <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
             <span class="n">aux</span><span class="p">)</span>

    <span class="n">AI_int</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">Kval</span> <span class="o">+=</span> <span class="n">K_aux</span>
    <span class="n">Vval</span> <span class="o">+=</span> <span class="n">V_aux</span>
    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">time_P2P</span> <span class="o">+=</span> <span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span>

    <span class="k">return</span> <span class="n">Kval</span><span class="p">,</span> <span class="n">Vval</span><span class="p">,</span> <span class="n">AI_int</span><span class="p">,</span> <span class="n">time_P2P</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">PyGBe</a></h1>



<p class="blurb">Python, GPUs and Boundary elements for biomolecular electrostatics</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=barbagroup&repo=pygbe&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<a href="http://dx.doi.org/10.21105/joss.00043"><img src="http://joss.theoj.org/papers/10.21105/joss.00043/status.svg"></a>
<a href="http://www.doi2bib.org/#/doi/10.21105/joss.00043"><img src="https://img.shields.io/badge/Cite%20PyGBe-bibtex-blue.svg"></a><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../run.html">Run PyGBe</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing PyGBe</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input_format.html">Input File Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input_format.html#parameters-file-format">Parameters file format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../othersoftware.html">Other software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../programmatic.html">Programmatic use of PyGBe</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Christopher Cooper, Natalia Clementi, Gil Forsyth, Lorena Barba.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>